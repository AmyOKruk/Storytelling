import discreteBuffer from "./discreteBuffer";
/**
    Adds a buffer to either side of the non-discrete axis.
    @param {Array} data
    @param {D3Scale} x
    @param {D3Scale} y
    @param {Object} [config]
    @param {Number} [buffer] Defaults to the radius of the largest Circle.
    @private
*/

export default function (_ref) {
  var data = _ref.data,
      x = _ref.x,
      y = _ref.y,
      x2 = _ref.x2,
      y2 = _ref.y2,
      config = _ref.config;
  var xKey = x2 ? "x2" : "x";
  var yKey = y2 ? "y2" : "y";
  var xD = x.domain().slice(),
      yD = y.domain().slice();
  var xR = x.range(),
      yR = y.range();
  if (!x.invert && x.padding) discreteBuffer(x, data, this._discrete);
  if (!y.invert && y.padding) discreteBuffer(y, data, this._discrete);
  data.forEach(function (d) {
    var h = config.height(d.data, d.i),
        w = config.width(d.data, d.i);

    if (x.invert && x(d[xKey]) - xR[0] < w) {
      var v = x.invert(x(d[xKey]) - w);
      if (v < xD[0]) xD[0] = v;
    }

    if (x.invert && xR[1] - x(d[xKey]) < w) {
      var _v = x.invert(x(d[xKey]) + w);

      if (_v > xD[1]) xD[1] = _v;
    }

    if (y.invert && y(d[yKey]) - yR[0] < h) {
      var _v2 = y.invert(y(d[yKey]) - h);

      if (_v2 > yD[0]) yD[0] = _v2;
    }

    if (y.invert && yR[1] - y(d[yKey]) < h) {
      var _v3 = y.invert(y(d[yKey]) + h);

      if (_v3 < yD[1]) yD[1] = _v3;
    }
  });
  x.domain(xD);
  y.domain(yD);
  return [x, y];
}