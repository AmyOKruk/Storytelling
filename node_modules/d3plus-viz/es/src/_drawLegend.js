import { nest } from "d3-collection";
import { configPrep, elem, merge } from "d3plus-common";
/**
    @function legendLabel
    @desc Default label function for the legend.
    @private
*/

export function legendLabel(d, i) {
  var l = this._drawLabel(d, i);

  return l instanceof Array ? l.join(", ") : l;
}
/**
    @function _drawLegend
    @desc Renders the legend if this._legend is not falsy.
    @param {Array} data The filtered data array to be displayed.
    @private
*/

export default function () {
  var _this = this;

  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  if (this._legend) {
    var legendBounds = this._legendClass.outerBounds();

    var position = this._legendPosition;
    var wide = ["top", "bottom"].includes(position);
    var padding = this._legendPadding() ? this._padding : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
    var transform = {
      transform: "translate(".concat(wide ? this._margin.left + padding.left : this._margin.left, ", ").concat(wide ? this._margin.top : this._margin.top + padding.top, ")")
    };
    var legendGroup = elem("g.d3plus-viz-legend", {
      condition: this._legend && !this._legendConfig.select,
      enter: transform,
      parent: this._select,
      transition: this._transition,
      update: transform
    }).node();
    var legendData = [];

    var color = function color(d, i) {
      var shape = _this._shape(d, i);

      var attr = shape === "Line" ? "stroke" : "fill";
      var value = _this._shapeConfig[shape] && _this._shapeConfig[shape][attr] ? _this._shapeConfig[shape][attr] : _this._shapeConfig[attr];
      return typeof value === "function" ? value(d, i) : value;
    };

    var opacity = function opacity(d, i) {
      var shape = _this._shape(d, i);

      var value = _this._shapeConfig[shape] && _this._shapeConfig[shape].opacity ? _this._shapeConfig[shape].opacity : _this._shapeConfig.opacity;
      return typeof value === "function" ? value(d, i) : value;
    };

    var fill = function fill(d, i) {
      return "".concat(color(d, i), "_").concat(opacity(d, i));
    };

    nest().key(fill).rollup(function (leaves) {
      return legendData.push(merge(leaves, _this._aggs));
    }).entries(this._colorScale ? data.filter(function (d, i) {
      return _this._colorScale(d, i) === undefined;
    }) : data);
    legendData.sort(this._legendSort);

    var hidden = function hidden(d, i) {
      var id = _this._id(d, i);

      if (id instanceof Array) id = id[0];
      return _this._hidden.includes(id) || _this._solo.length && !_this._solo.includes(id);
    };

    this._legendClass.id(fill).align(wide ? "center" : position).direction(wide ? "row" : "column").duration(this._duration).data(legendData.length > this._legendCutoff || this._colorScale ? legendData : []).height(wide ? this._height - (this._margin.bottom + this._margin.top) : this._height - (this._margin.bottom + this._margin.top + padding.bottom + padding.top)).locale(this._locale).select(legendGroup).verticalAlign(!wide ? "middle" : position).width(wide ? this._width - (this._margin.left + this._margin.right + padding.left + padding.right) : this._width - (this._margin.left + this._margin.right)).shapeConfig(configPrep.bind(this)(this._shapeConfig, "legend")).config(this._legendConfig).shapeConfig({
      fill: function fill(d, i) {
        return hidden(d, i) ? _this._hiddenColor(d, i) : color(d, i);
      },
      labelConfig: {
        fontOpacity: function fontOpacity(d, i) {
          return hidden(d, i) ? _this._hiddenOpacity(d, i) : 1;
        }
      },
      opacity: opacity
    }).render();

    if (!this._legendConfig.select && legendBounds.height) {
      if (wide) this._margin[position] += legendBounds.height + this._legendClass.padding() * 2;else this._margin[position] += legendBounds.width + this._legendClass.padding() * 2;
    }
  }
}